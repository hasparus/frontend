{"ast":null,"code":"export function match(key) {\n  return function match1(value, cases) {\n    return cases[value[key]](value);\n  };\n}\nexport const matchType = match(\"type\");\nexport const matchKind = match(\"kind\");","map":{"version":3,"sources":["/home/hasparus/workspace/zagrajmy/frontend/packages/app/src/lib/match.tsx"],"names":["match","key","match1","value","cases","matchType","matchKind"],"mappings":"AAcA,OAAO,SAASA,KAAT,CAA8BC,GAA9B,EAAsC;AAC3C,SAAO,SAASC,MAAT,CACLC,KADK,EAELC,KAFK,EAGmB;AACxB,WAAOA,KAAK,CAACD,KAAK,CAACF,GAAD,CAAN,CAAL,CAAkBE,KAAlB,CAAP;AACD,GALD;AAMD;AAED,OAAO,MAAME,SAAS,GAAGL,KAAK,CAAC,MAAD,CAAvB;AACP,OAAO,MAAMM,SAAS,GAAGN,KAAK,CAAC,MAAD,CAAvB","sourcesContent":["type Key = string | number;\n\ntype Sigil<K extends Key, T extends string = string> = {\n  [_ in K]: T;\n};\n\ntype TypeOf<K extends Key, T extends Sigil<K>> = T[K];\n\ntype FilterType<T, Matching> = T extends Matching ? T : never;\n\ntype Cases<K extends Key, T extends Record<K, any>, R> = {\n  [P in TypeOf<K, T>]: (val: FilterType<T, { type: P }>) => R;\n};\n\nexport function match<K extends Key>(key: K) {\n  return function match1<T extends Sigil<K>, C extends Cases<K, T, any>>(\n    value: T,\n    cases: C\n  ): ReturnType<C[keyof C]> {\n    return cases[value[key]](value as FilterType<T, { type: string }>);\n  };\n}\n\nexport const matchType = match(\"type\");\nexport const matchKind = match(\"kind\");\n"]},"metadata":{},"sourceType":"module"}